"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[3248],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>m});var i=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,i,a=function(e,t){if(null==e)return{};var n,i,a={},l=Object.keys(e);for(i=0;i<l.length;i++)n=l[i],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(i=0;i<l.length;i++)n=l[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=i.createContext({}),p=function(e){var t=i.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},c=function(e){var t=p(e.components);return i.createElement(s.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},d=i.forwardRef((function(e,t){var n=e.components,a=e.mdxType,l=e.originalType,s=e.parentName,c=o(e,["components","mdxType","originalType","parentName"]),d=p(n),m=a,k=d["".concat(s,".").concat(m)]||d[m]||u[m]||l;return n?i.createElement(k,r(r({ref:t},c),{},{components:n})):i.createElement(k,r({ref:t},c))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var l=n.length,r=new Array(l);r[0]=d;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o.mdxType="string"==typeof e?e:a,r[1]=o;for(var p=2;p<l;p++)r[p]=n[p];return i.createElement.apply(null,r)}return i.createElement.apply(null,n)}d.displayName="MDXCreateElement"},327:(e,t,n)=>{n.r(t),n.d(t,{contentTitle:()=>r,default:()=>c,frontMatter:()=>l,metadata:()=>o,toc:()=>s});var i=n(7462),a=(n(7294),n(3905));const l={sidebar_label:"code_utils",title:"code_utils"},r=void 0,o={unversionedId:"reference/code_utils",id:"reference/code_utils",isDocsHomePage:!1,title:"code_utils",description:"infer\\_lang",source:"@site/docs/reference/code_utils.md",sourceDirName:"reference",slug:"/reference/code_utils",permalink:"/autogen/docs/reference/code_utils",editUrl:"https://github.com/microsoft/autogen/edit/main/website/docs/reference/code_utils.md",tags:[],version:"current",frontMatter:{sidebar_label:"code_utils",title:"code_utils"},sidebar:"referenceSideBar",previous:{title:"openai_utils",permalink:"/autogen/docs/reference/oai/openai_utils"},next:{title:"math_utils",permalink:"/autogen/docs/reference/math_utils"}},s=[{value:"infer_lang",id:"infer_lang",children:[],level:4},{value:"extract_code",id:"extract_code",children:[],level:4},{value:"generate_code",id:"generate_code",children:[],level:4},{value:"improve_function",id:"improve_function",children:[],level:4},{value:"improve_code",id:"improve_code",children:[],level:4},{value:"execute_code",id:"execute_code",children:[],level:4},{value:"generate_assertions",id:"generate_assertions",children:[],level:4},{value:"eval_function_completions",id:"eval_function_completions",children:[],level:4},{value:"PassAssertionFilter Objects",id:"passassertionfilter-objects",children:[{value:"pass_assertions",id:"pass_assertions",children:[],level:4},{value:"implement",id:"implement",children:[],level:4}],level:2}],p={toc:s};function c(e){let{components:t,...n}=e;return(0,a.kt)("wrapper",(0,i.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h4",{id:"infer_lang"},"infer","_","lang"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},"def infer_lang(code)\n")),(0,a.kt)("p",null,"infer the language for the code.\nTODO: make it robust."),(0,a.kt)("h4",{id:"extract_code"},"extract","_","code"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},"def extract_code(\n        text: str,\n        pattern: str = CODE_BLOCK_PATTERN,\n        detect_single_line_code: bool = False) -> List[Tuple[str, str]]\n")),(0,a.kt)("p",null,"Extract code from a text."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"text")," ",(0,a.kt)("em",{parentName:"li"},"str")," - The text to extract code from."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"pattern")," ",(0,a.kt)("em",{parentName:"li"},"str, optional")," - The regular expression pattern for finding the\ncode block. Defaults to CODE_BLOCK_PATTERN."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"detect_single_line_code")," ",(0,a.kt)("em",{parentName:"li"},"bool, optional")," - Enable the new feature for\nextracting single line code. Defaults to False.")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Returns"),":"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"list"),' - A list of tuples, each containing the language and the code.\nIf there is no code block in the input text, the language would be "unknown".\nIf there is code block but the language is not specified, the language would be "".')),(0,a.kt)("h4",{id:"generate_code"},"generate","_","code"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},"def generate_code(pattern: str = CODE_BLOCK_PATTERN,\n                  **config) -> Tuple[str, float]\n")),(0,a.kt)("p",null,"Generate code."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"pattern")," ",(0,a.kt)("em",{parentName:"li"},"Optional, str")," - The regular expression pattern for finding the code block.\nThe default pattern is for finding a code block in a markdown file."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"config")," ",(0,a.kt)("em",{parentName:"li"},"Optional, dict")," - The configuration for the API call.")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Returns"),":"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"str")," - The generated code."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"float")," - The cost of the generation.")),(0,a.kt)("h4",{id:"improve_function"},"improve","_","function"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},"def improve_function(file_name, func_name, objective, **config)\n")),(0,a.kt)("p",null,"(work in progress) Improve the function to achieve the objective."),(0,a.kt)("h4",{id:"improve_code"},"improve","_","code"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},"def improve_code(files, objective, suggest_only=True, **config)\n")),(0,a.kt)("p",null,"Improve the code to achieve a given objective."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"files")," ",(0,a.kt)("em",{parentName:"li"},"list")," - A list of file names containing the source code."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"objective")," ",(0,a.kt)("em",{parentName:"li"},"str")," - The objective to achieve."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"suggest_only")," ",(0,a.kt)("em",{parentName:"li"},"bool")," - Whether to return only the suggestions or the improved code."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"config")," ",(0,a.kt)("em",{parentName:"li"},"Optional, dict")," - The configuration for the API call.")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Returns"),":"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"str")," - The improved code if suggest_only=False; a list of suggestions if suggest_only=True (default)."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"float")," - The cost of the generation.")),(0,a.kt)("h4",{id:"execute_code"},"execute","_","code"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},'def execute_code(code: Optional[str] = None,\n                 timeout: Optional[int] = None,\n                 filename: Optional[str] = None,\n                 work_dir: Optional[str] = None,\n                 use_docker: Optional[Union[List[str], str, bool]] = None,\n                 lang: Optional[str] = "python") -> Tuple[int, str, str]\n')),(0,a.kt)("p",null,"Execute code in a docker container.\nThis function is not tested on MacOS."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"code")," ",(0,a.kt)("em",{parentName:"li"},"Optional, str")," - The code to execute.\nIf None, the code from the file specified by filename will be executed.\nEither code or filename must be provided."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"timeout")," ",(0,a.kt)("em",{parentName:"li"},"Optional, int")," - The maximum execution time in seconds.\nIf None, a default timeout will be used. The default timeout is 600 seconds. On Windows, the timeout is not enforced when use_docker=False."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"filename")," ",(0,a.kt)("em",{parentName:"li"},"Optional, str")," - The file name to save the code or where the code is stored when ",(0,a.kt)("inlineCode",{parentName:"li"},"code")," is None.\nIf None, a file with a randomly generated name will be created.\nThe randomly generated file will be deleted after execution.\nThe file name must be a relative path. Relative paths are relative to the working directory."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"work_dir")," ",(0,a.kt)("em",{parentName:"li"},"Optional, str"),' - The working directory for the code execution.\nIf None, a default working directory will be used.\nThe default working directory is the "extensions" directory under\n"path_to_autogen".'),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"use_docker")," ",(0,a.kt)("em",{parentName:"li"},"Optional, list, str or bool")," - The docker image to use for code execution.\nIf a list or a str of image name(s) is provided, the code will be executed in a docker container\nwith the first image successfully pulled.\nIf None, False or empty, the code will be executed in the current environment.\nDefault is None, which will be converted into an empty list when docker package is available.\nExpected behaviour:",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"If ",(0,a.kt)("inlineCode",{parentName:"li"},"use_docker")," is explicitly set to True and the docker package is available, the code will run in a Docker container."),(0,a.kt)("li",{parentName:"ul"},"If ",(0,a.kt)("inlineCode",{parentName:"li"},"use_docker")," is explicitly set to True but the Docker package is missing, an error will be raised."),(0,a.kt)("li",{parentName:"ul"},"If ",(0,a.kt)("inlineCode",{parentName:"li"},"use_docker")," is not set (i.e., left default to None) and the Docker package is not available, a warning will be displayed, but the code will run natively.\nIf the code is executed in the current environment,\nthe code must be trusted."))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"lang")," ",(0,a.kt)("em",{parentName:"li"},"Optional, str"),' - The language of the code. Default is "python".')),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Returns"),":"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"int")," - 0 if the code executes successfully."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"str")," - The error message if the code fails to execute; the stdout otherwise."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"image")," - The docker image name after container run when docker is used.")),(0,a.kt)("h4",{id:"generate_assertions"},"generate","_","assertions"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},"def generate_assertions(definition: str, **config) -> Tuple[str, float]\n")),(0,a.kt)("p",null,"Generate assertions for a function."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"definition")," ",(0,a.kt)("em",{parentName:"li"},"str")," - The function definition, including the signature and docstr."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"config")," ",(0,a.kt)("em",{parentName:"li"},"Optional, dict")," - The configuration for the API call.")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Returns"),":"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"str")," - The generated assertions."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"float")," - The cost of the generation.")),(0,a.kt)("h4",{id:"eval_function_completions"},"eval","_","function","_","completions"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},"def eval_function_completions(responses: List[str],\n                              definition: str,\n                              test: Optional[str] = None,\n                              entry_point: Optional[str] = None,\n                              assertions: Optional[Union[str, Callable[\n                                  [str], Tuple[str, float]]]] = None,\n                              timeout: Optional[float] = 3,\n                              use_docker: Optional[bool] = True) -> Dict\n")),(0,a.kt)("p",null,"Select a response from a list of responses for the function completion task (using generated assertions), and/or evaluate if the task is successful using a gold test."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"responses")," ",(0,a.kt)("em",{parentName:"li"},"list")," - The list of responses."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"definition")," ",(0,a.kt)("em",{parentName:"li"},"str")," - The input definition."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"test")," ",(0,a.kt)("em",{parentName:"li"},"Optional, str")," - The test code."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"entry_point")," ",(0,a.kt)("em",{parentName:"li"},"Optional, str")," - The name of the function."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"assertions")," ",(0,a.kt)("em",{parentName:"li"},"Optional, str or Callable")," - The assertion code which serves as a filter of the responses, or an assertion generator.\nWhen provided, only the responses that pass the assertions will be considered for the actual test (if provided)."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"timeout")," ",(0,a.kt)("em",{parentName:"li"},"Optional, float")," - The timeout for executing the code.")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Returns"),":"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"dict")," - The success metrics.")),(0,a.kt)("h2",{id:"passassertionfilter-objects"},"PassAssertionFilter Objects"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},"class PassAssertionFilter()\n")),(0,a.kt)("h4",{id:"pass_assertions"},"pass","_","assertions"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},"def pass_assertions(context, response, **_)\n")),(0,a.kt)("p",null,"Check if the response passes the assertions."),(0,a.kt)("h4",{id:"implement"},"implement"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},"def implement(\n    definition: str,\n    configs: Optional[List[Dict]] = None,\n    assertions: Optional[Union[str,\n                               Callable[[str],\n                                        Tuple[str,\n                                              float]]]] = generate_assertions\n) -> Tuple[str, float]\n")),(0,a.kt)("p",null,"Implement a function from a definition."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"definition")," ",(0,a.kt)("em",{parentName:"li"},"str")," - The function definition, including the signature and docstr."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"configs")," ",(0,a.kt)("em",{parentName:"li"},"list")," - The list of configurations for completion."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"assertions")," ",(0,a.kt)("em",{parentName:"li"},"Optional, str or Callable")," - The assertion code which serves as a filter of the responses, or an assertion generator.")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Returns"),":"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"str")," - The implementation."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"float")," - The cost of the implementation."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"int")," - The index of the configuration which generates the implementation.")))}c.isMDXComponent=!0}}]);